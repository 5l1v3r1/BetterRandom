// ============================================================================
//   Copyright 2006-2012 Daniel W. Dyer
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
// ============================================================================
package io.github.pr0methean.betterrandom.util

import java.lang.ThreadLocal.withInitial

import java.nio.ByteBuffer

/**
 * Utility methods for working with binary and hex data.
 * @author Daniel Dyer
 */
enum class BinaryUtils {
    ;

    companion object {

        private val LONG_BYTE_ARRAY = withInitial { ByteArray(java.lang.Long.BYTES) }
        private val LONG_BYTE_BUFFER = withInitial { ByteBuffer.wrap(LONG_BYTE_ARRAY.get()) }
        private val INT_BYTE_ARRAY = withInitial { ByteArray(Integer.BYTES) }
        private val INT_BYTE_BUFFER = withInitial { ByteBuffer.wrap(INT_BYTE_ARRAY.get()) }

        // Mask for casting a byte to an int, bit-by-bit (with
        // bitwise AND) with no special consideration for the sign bit.
        private val BITWISE_BYTE_TO_INT = 0x000000FF

        private val HEX_CHARS = charArrayOf('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F')

        /**
         * Converts an array of bytes into a String of hexadecimal characters (0 - F).
         * @param data An array of bytes to convert to a String.
         * @return A hexadecimal String representation of the data.
         */
        fun convertBytesToHexString(data: ByteArray?): String {
            if (data == null) {
                return "null"
            }
            val buffer = StringBuilder(data.size * 2)
            for (b in data) {
                buffer.append(HEX_CHARS[b.ushr(4) and 0x0F])
                buffer.append(HEX_CHARS[b and 0x0F])
            }
            return buffer.toString()
        }

        /**
         * Converts an array of ints into a String of hexadecimal characters (0 - F), taking only the
         * least significant byte of each int. Prepends a newline, unless returning "null".
         * @param data An array of ints to convert to a String.
         * @return A hexadecimal String representation of the data.
         */
        fun convertIntLeastBytesToHexString(data: IntArray?): String {
            if (data == null) {
                return "null"
            }
            val buffer = StringBuilder(data.size * 2 + 1)
            buffer.append('\n')
            for (b in data) {
                buffer.append(HEX_CHARS[b.ushr(4) and 0x0F])
                buffer.append(HEX_CHARS[b and 0x0F])
            }
            return buffer.toString()
        }

        /**
         * Converts a hexadecimal String (such as one generated by the [ ][.convertBytesToHexString] method) into an array of bytes.
         * @param hex The hexadecimal String to be converted into an array of bytes.
         * @return An array of bytes that.
         */
        fun convertHexStringToBytes(
                hex: String): ByteArray {
            if (hex.length % 2 != 0) {
                throw IllegalArgumentException("Hex string must have even number of characters.")
            }
            val seed = ByteArray(hex.length / 2)
            for (i in seed.indices) {
                val index = i * 2
                seed[i] = Integer.parseInt(hex.substring(index, index + 2), 16).toByte()
                // Can't use Byte.parseByte since it expects signed
            }
            return seed
        }

        /**
         * Take four bytes from the specified position in the specified block and convert them into a
         * 32-bit int, using the big-endian convention.
         * @param bytes The data to read from.
         * @param offset The position to start reading the 4-byte int from.
         * @return The 32-bit integer represented by the four bytes.
         */
        fun convertBytesToInt(bytes: ByteArray, offset: Int): Int {
            return BITWISE_BYTE_TO_INT and bytes[offset + 3] or (BITWISE_BYTE_TO_INT and bytes[offset + 2] shl 8) or (BITWISE_BYTE_TO_INT and bytes[offset + 1] shl 16) or (BITWISE_BYTE_TO_INT and bytes[offset] shl 24)
        }

        /**
         * Convert an array of bytes into an array of ints.  4 bytes from the input data map to a single
         * int in the output data.
         * @param bytes The data to read from.
         * @return An array of 32-bit integers constructed from the data.
         * @since 1.1
         */
        fun convertBytesToInts(bytes: ByteArray): IntArray {
            if (bytes.size % 4 != 0) {
                throw IllegalArgumentException("Number of input bytes must be a multiple of 4.")
            }
            val ints = IntArray(bytes.size / 4)
            for (i in ints.indices) {
                ints[i] = convertBytesToInt(bytes, i * 4)
            }
            return ints
        }

        /**
         * Utility method to convert an array of bytes into a long.  Byte ordered is assumed to be
         * big-endian.
         * @param bytes The data to read from.
         * @param offset The position to start reading the 8-byte long from.
         * @return The 64-bit integer represented by the eight bytes.
         */
        @JvmOverloads
        fun convertBytesToLong(bytes: ByteArray, offset: Int = 0): Long {
            var value: Long = 0
            for (i in offset until offset + 8) {
                val b = bytes[i]
                value = value shl 8
                value = value or b.toLong()
            }
            return value
        }

        /**
         * Converts a long to an array of bytes.
         * @param input a long.
         * @return an array of 8 bytes containing the long's value in
         * [java.nio.ByteOrder.BIG_ENDIAN] order.
         */
        fun convertLongToBytes(input: Long): ByteArray {
            LONG_BYTE_BUFFER.get().putLong(0, input)
            return LONG_BYTE_ARRAY.get()
        }

        /**
         *
         * convertIntToBytes.
         * @param input an int.
         * @return an array of 4 bytes containing the int's value in
         * [java.nio.ByteOrder.BIG_ENDIAN] order.
         */
        fun convertIntToBytes(input: Int): ByteArray {
            INT_BYTE_BUFFER.get().putInt(0, input)
            return INT_BYTE_ARRAY.get()
        }
    }
}
/**
 * Convert a byte array to a long, reversing [.convertLongToBytes].
 * @param bytes a byte array of length [Long.BYTES] in
 * [java.nio.ByteOrder.BIG_ENDIAN] order.
 * @return `bytes` as a long.
 */
